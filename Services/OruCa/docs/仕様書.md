## 📝 OruCa技術仕様書

---

### 1. はじめに

#### 1.1. OruCaの概要
OruCaは、FeliCaカードを利用して研究室メンバーの在室状況をリアルタイムに管理・表示するウェブアプリケーションである。

#### 1.2. 本仕様書の目的
本仕様書は、OruCaシステムの技術的側面、すなわちアーキテクチャ、各コンポーネントの役割、および主要なデータフローを文書化することを目的とする。

---

### 2. システムアーキテクチャ

#### 2.1. 全体構成（コンテナ間の関連性）
本システムは、物理的な「NFCリーダー」からの入力を「バックエンドAPI」が受け取り、「データベース」を更新し、その結果をリアルタイムで「フロントエンド（Web）」に反映させる構成である。

* **ユーザー (ブラウザ)**
    * **→ `web` (Nginx) または `vite` (開発サーバー):**
        * 本番環境では `web`、開発環境では `vite` にアクセスし、フロントエンド画面を受信する。

* **`vite` (開発用フロント)**
    * **→ `api` (バックエンド):**
        * WebSocket接続 (`/socket`) を `api` サービス (のポート3000) に対して確立する。
        * HTTPリクエスト (`/api/*`) も `api` サービスに送信する。

* **`web` (本番用フロント / Nginx)**
    * **→ `api` (バックエンド):**
        * `web` (Nginx) は、ユーザー（ブラウザ）からの特定のリクエストを `api` サービスに転送（リバースプロキシ）する。
        * `location /socket` (WebSocket通信) は `http://oruca-api:3000` へ転送される。
        * `location /api` (HTTP通信) は `http://oruca-api:3000` へ転送される。
    * **依存関係:** `web` は `api` の起動後に起動する (`depends_on: - api`)。

* **`api` (バックエンド)**
    * **← `web` / `vite` (フロントエンド):**
        * フロントエンドからのWebSocket接続 (`/socket`) とHTTPリクエスト (`/api/*`) を受け付ける。
    * **← `nfc` (NFCリーダー):**
        * `nfc` サービスから、`ws://oruca-api:3000/log/write` というエンドポイントでWebSocket接続を受け付ける。
        * カードIDを含む `log/write` メッセージを受信する。
    * **→ `mysql` (データベース):**
        * `mysql` サービスに接続し、データの読み書き（ログ取得、ログ更新/挿入、ユーザー認証など）を行う。
    * **→ `web` / `vite` (フロントエンド):**
        * `nfc` から `log/write` を受信した際や、HTTPで `/admin/reset_all` が実行された際、接続中の全てのフロントエンドクライアントに対し、更新された在室状況 (`log/fetch` メッセージ) をWebSocketでブロードキャストする。
    * **→ Slack (外部サービス):**
        * `log/write` 処理時、環境変数（`SLACK_BOT_TOKEN` 等）が設定されていれば、Slack APIに在室・退室通知を送信する。
    * **依存関係:** `api` は `mysql` が正常に起動 (healthy) してから起動する (`depends_on: mysql: condition: service_healthy`)。

* **`nfc` (NFCリーダー)**
    * **→ 物理USBデバイス:**
        * ホストマシンに接続されたUSBデバイス（FeliCaリーダー）にアクセスする (`devices: - "/dev/bus/usb:/dev/bus/usb"`)。
    * **→ `api` (バックエンド):**
        * カードがリーダーから離れた（`on_release`）タイミングで、`api` サービスの `ws://oruca-api:3000/log/write` エンドポイントにWebSocketで接続し、学生IDを含む `log/write` メッセージを発行（Pub）する。
    * **依存関係:** `nfc` は `mysql` が正常に起動 (healthy) してから起動する。

* **`mysql` (データベース)**
    * **← `api` (バックエンド):**
        * `api` サービスからのデータベース接続（CRUD操作）を受け付ける。
    * **依存先:** `api` と `nfc` サービスが `mysql` に依存する。
    * **永続化:** データベースファイルは `mysql_data` という名前付きボリュームに保存される。

* **ネットワーク**
    * 上記の全コンテナは `default` ネットワークに属し、コンテナ名で相互通信が可能である。
    * `web` サービスは `fukaya-lab-network` (外部ネットワーク) にも接続し、外部のリバースプロキシ (Caddy等) から `http://oruca.fukaya-sus.lab` 宛のトラフィックを受け付ける設定を持つ。

#### 2.2. コンポーネント（サービス）一覧
`docker-compose.yml` に基づき、以下のサービス（コンテナ）で構成される。

| サービス名 | コンテナ名 | 役割 | プロファイル |
| :--- | :--- | :--- | :--- |
| `vite` | `oruca-vite` | 開発用フロントエンドサーバー (Vite) | `dev` |
| `web` | `oruca-web` | 本番用Webサーバー (Nginx) / リバースプロキシ | `prod` |
| `mysql` | `oruca-mysql` | データベースサーバー (MySQL) | `dev`, `prod` |
| `api` | `oruca-api` | バックエンド APIサーバー (Node.js) | `dev`, `prod` |
| `nfc` | `oruca-nfc` | NFCカードリーダー連携 (Python) | `dev`, `prod` |

#### 2.3. 使用技術スタック
`README.md` に基づく主要な技術スタックは以下の通りである。

* **フロントエンド:** Vite, React, TypeScript, Chakra UI
* **バックエンド:** Node.js, Express, TypeScript, WebSocket
* **データベース:** MySQL
* **NFC連携:** Python
* **インフラ:** Docker, Docker Compose

---

### 3. コンポーネント（サービス）詳説

#### 3.1. `api` (バックエンド APIサーバー)
Node.js (Express) で構築されたAPIサーバー。HTTPエンドポイントとWebSocketエンドポイントを提供し、ビジネスロジック（DB操作、Slack通知、クライアントへのブロードキャスト）を担う。

#### 3.2. `web` (本番用フロントエンド/リバースプロキシ)
Nginxを使用。Reactのビルド成果物（静的ファイル）を配信する。また、`/api/*` および `/socket` 宛のHTTP/WebSocketリクエストを `api` サービス (oruca-api:3000) へリバースプロキシする。

#### 3.3. `vite` (開発用フロントエンド)
開発環境（`dev` プロファイル）でのみ使用される。Vite開発サーバーとして機能し、ホットリロードなど開発支援機能を提供する。

#### 3.4. `mysql` (データベース)
MySQLサーバー。ユーザー情報 (`users` テーブル) と在室ログ (`logs` テーブル) を永続化する。データは `mysql_data` ボリュームに格納される。

#### 3.5. `nfc` (NFCリーダー連携)
Pythonスクリプト (`main.py`) を実行する。ホストのUSBデバイスに接続されたFeliCaリーダーを制御し、読み取ったカードIDを `api` サービスのWebSocket (`ws://oruca-api:3000/log/write`) へ送信する。

---

### 4. データベース (mysql) 設計
`mysql/data/init.sql` に基づく設計。

#### 4.1. テーブル定義
* **`users`**: ユーザー情報を格納。
    * `student_ID` (VARCHAR(16), PK): 学生証ID。
    * `student_Name` (VARCHAR(64)): 氏名。
    * `student_token` (VARCHAR(64)): 認証用トークン（ハッシュ値）。
* **`logs`**: 在室ログを格納。
    * `student_ID` (VARCHAR(16), PK, FK -> users.student_ID): 学生証ID。
    * `isInRoom` (BOOLEAN): 在室状況 (True: 在室, False: 退室)。
    * `updated_at` (TIMESTAMP): 最終更新日時。

#### 4.2. ビュー定義
* **`student_token_view`**: `users` と `logs` を結合し、`student_ID` と `student_token` を提供。
* **`student_log_view`**: `logs` と `users` を結合し、ID、氏名、在室状況、更新日時を提供 (フロントエンド表示用)。
* **`student_name_view`**: `logs` と `users` を結合し、ID と氏名を提供。

#### 4.3. ストアドプロシージャ
* **`insert_or_update_log(IN stuID VARCHAR(16))`**:
    1.  `stuID` が `users` テーブルに存在しない場合、新規登録する。
    2.  その際、`admin_pass` ('fukaya_lab') と `stuID` からトークン (`student_token`) を生成し保存する。
    3.  `logs` テーブルに対し、`stuID` が存在すれば `isInRoom` の値を反転 (True/False) させ、存在しなければ `isInRoom = TRUE` として新規挿入する。
* **`update_student_name(IN stuID VARCHAR(16), IN stuName VARCHAR(64))`**:
    * `users` テーブルの `student_Name` を更新する。
* **`get_student_token(IN stuID VARCHAR(16))`**:
    * `student_token_view` から指定された `stuID` の `student_token` を取得する。

#### 4.4. 認証トークン生成ロジック
`insert_or_update_log` プロシージャ および `MessageHandler.ts` における認証ロジックは、以下のハッシュ生成方法に依存する。

1.  **Salt**: `SHA2(stuID, 256)`
2.  **Token**: `SHA2(CONCAT(stuID, admin_pass, Salt), 256)`

`admin_pass` は 'fukaya_lab' にハードコードされている。

---

### 5. バックエンド (api) 仕様

#### 5.1. 起動プロセス
`api/server.ts` により、以下の順序で初期化が実行される。

1.  `DatabaseHandler` が `mysql` への接続を試行。失敗時はプロセス終了。
2.  `ServerHandler` が初期化され、HTTPサーバー (Express) と WebSocketサーバー (ws) がセットアップされる。
3.  HTTPサーバーがポート 3000 (デフォルト) でリッスンを開始する。
4.  `SIGTERM` または `SIGINT` シグナル受信時に、`DatabaseHandler` の接続を閉じてからHTTPサーバーを閉じるシャットダウン処理を実行する。

#### 5.2. ルーティング (Nginx と APIサーバー)
`web/default.conf` により、本番環境では以下のルーティングが設定される。

* `http://<host>/socket` → `http://oruca-api:3000` (WebSocket)
* `http://<host>/api/*` → `http://oruca-api:3000` (HTTP)

`api` サービス内部 (`HttpHandler.ts`) では、`/api` プレフィックスを**除いた**パス (例: `/echo`, `/admin/reset_all`) でルートが定義されている。

#### 5.3. HTTP API エンドポイント
`HttpHandler.ts` で定義される主要なエンドポイント。

* **`GET /echo`** (アクセスパス: `/api/echo`)
    * 疎通確認用。`"http(api) is connected\n"` をJSONで返す。
* **`POST /admin/reset_all`** (アクセスパス: `/api/admin/reset_all`)
    * 全ユーザーの `isInRoom` を `false` (退室) に設定するよう `DatabaseHandler` に指示する。
    * 処理後、`onDataUpdated` コールバック（`WebSocketHandler` の `broadcastData`）を呼び出し、全クライアントに最新状況をブロードキャストする。

#### 5.4. WebSocket API (メッセージ仕様)
`MessageHandler.ts` で処理される主要なメッセージタイプ。

* **受信 (Client/NFC -> API)**
    * **`log/fetch`**: クライアントからのログ取得要求。現在の全ログ (`student_log_view`) を要求元クライアントに送信する。
    * **`log/write`**: `nfc` サービスから送信される入退室記録。`insert_or_update_log` を実行し、Slack通知を行い、全クライアントに `log/fetch` をブロードキャストする。
    * **`user/auth`**: 管理者ログイン試行。ペイロードの `student_ID` と `password` を使用し、4.4節のロジックでトークンを比較検証する。
    * **`user/update_name`**: 氏名更新要求。`update_student_name` を実行し、全クライアントにブロードキャストする。
    * **`user/fetchToken`**: トークン取得要求。
    * **`user/delete`**: ユーザー削除要求。`users` テーブルから該当レコードを削除 (logsもCASCADE削除) し、全クライアントにブロードキャストする。
* **送信 (API -> Client)**
    * **`log/fetch`**: `log/write` 処理後、または `log/fetch` 受信時、または `WebSocketHandler` での新規接続時に送信される。
    * **`user/auth`**: 認証結果（成功/失敗、成功時はトークン）を要求元クライアントに返却する。
    * **`ack`**: 各種リクエスト（`log/write`, `user/update_name` 等）の処理失敗時に送信されることがある。

#### 5.5. データ検証
`MessageHandler.ts` では、`zod` ライブラリを使用し、受信したWebSocketメッセージのペイロード構造を検証する。

---

### 6. NFC連携 (nfc) 仕様
`nfc/main.py` に基づく仕様。

#### 6.1. 役割と処理フロー
`nfc.ContactlessFrontend("usb")` を使用し、USB接続されたNFCリーダーをポーリングする。

1.  **`on_connect` (カード接続時)**:
    * システムコード `0xFE00` でポーリングを実行する。
    * `get_student_ID` メソッドでIDを読み取る。
    * 読み取ったIDをインスタンス変数 `_card_id_to_publish` に一時保存する。この時点ではAPIに送信しない（多重送信防止）。
2.  **`on_release` (カード解放時)**:
    * `_card_id_to_publish` にIDが保存されている場合のみ、`publish_student_id` メソッドを呼び出す。
    * 呼び出し後、`_card_id_to_publish` を `None` にクリアする。

#### 6.2. ID抽出ロジック
`get_student_ID` 静的メソッドによる。

* ServiceCode `0x010B` (106, 0b001011)、BlockCode `0` を使用し、暗号化なしでデータを読み取る。
* 読み取ったバイトデータをUTF-8デコードし、分類コード（先頭2文字）に応じてID部分（3〜9文字目）を抽出する。
    * `"01"` または `"02"` (学生)
    * `"11"` (職員)

#### 6.3. APIへの送信データ
`publish_student_id` メソッドによる。

* **エンドポイント**: `ws://oruca-api:3000/log/write`
* **メッセージ形式**: `type` と `payload` を含むJSON文字列。
* **`type`**: `log/write`
* **`payload`**: `{"result": True, "content": {"student_ID": "..."}, "message": "..."}` 形式のオブジェクト。

---

### 7. フロントエンド (vite/web) 仕様

#### 7.1. WebSocket接続管理
`vite/src/App/contexts/WebSocketContext.tsx` による。

* **接続先**: `API_URL = '/socket'` (NginxまたはVite開発サーバーによりプロキシされる)。
* **接続処理**: `connectWebSocket` 関数がWebSocket接続を試行する。
* **再接続処理**: `onclose` イベント発火時、5秒間隔で `connectWebSocket` を再試行するインターバル (`reconnectIntervalRef`) を設定する。`onopen` 成功時にインターバルはクリアされる。
* **データ要求**: `requestData` 関数は、`log/fetch` メッセージを送信するために使用される。

#### 7.2. 本番環境プロキシ設定
`web/default.conf` による。

* `location /` (ルート): Reactアプリの `index.html` を返す (`try_files $uri $uri/ /index.html`)。
* `location ~ ^/socket`: WebSocket通信。`oruca-api:3000` へプロキシ。WebSocketヘッダー (`Upgrade`, `Connection`) を設定。
* `location ~ ^/api`: HTTP API通信。`oruca-api:3000` へプロキシ。

---

### 8. 主要データフロー

#### 8.1. フロー1: NFCカードによる入退室
1.  **NFC**: ユーザーがカードをタッチし、離す。`nfc` サービスが `on_release` でカードIDを取得。
2.  **NFC -> API**: `nfc` は `api` の `ws://.../log/write` エンドポイントへIDを含む `log/write` メッセージを送信。
3.  **API**: `MessageHandler` が `log/write` を受信。
4.  **API -> DB**: `api` は `mysql` の `insert_or_update_log` ストアドプロシージャを実行。`users` テーブルへの登録（初回時）と `logs` テーブルの `isInRoom` 反転が行われる。
5.  **API -> Slack**: `api` はSlackServiceを経由し、入退室通知をSlackへ投稿する。
6.  **API -> FrontEnd**: `api` は `broadcastData` を呼び出し、接続中の全クライアント（ブラウザ）へ `log/fetch` メッセージ（更新後の全ログ）をブロードキャストする。
7.  **FrontEnd**: ブラウザが `log/fetch` を受信し、在室状況テーブルを更新する。

#### 8.2. フロー2: 管理者ログイン
1.  **FrontEnd**: ユーザーが管理者ログインページでIDとパスワードを入力。
2.  **FrontEnd -> API**: ブラウザが `user/auth` メッセージ (ID, password) をWebSocketで送信。
3.  **API**: `MessageHandler` が `user/auth` を受信。
4.  **API -> DB**: `api` は `mysql` の `get_student_token` を実行し、保存されたトークンを取得。
5.  **API**: `api` 内部で、受信したパスワードとIDから期待されるトークンを生成し (4.4節参照)、DBから取得したトークンと比較する。
6.  **API -> FrontEnd**: `api` は認証結果（成功/失敗、成功時はトークンも含む）を `user/auth` メッセージとして送信元クライアントに返却する。
7.  **FrontEnd**: ブラウザが認証結果を受け取り、成功なら管理者ページへ遷移、失敗ならエラーを表示する。

#### 8.3. フロー3: 在室状況の初期表示
1.  **FrontEnd**: ユーザーがOruCaのページ（`/`）にアクセス。
2.  **FrontEnd -> API**: `WebSocketContext` が `/socket` エンドポイントへのWebSocket接続を開始する。
3.  **API**: `WebSocketHandler` が `connection` イベントを検知。
4.  **API -> DB**: `handleConnection` 関数内で `messageHandler.fetchLogs()` が呼び出され、`mysql` から現在の全ログ (`student_log_view`) を取得する。
5.  **API -> FrontEnd**: `api` は取得した全ログを `log/fetch` メッセージとして、接続してきたクライアントに送信する。
6.  **FrontEnd**: ブラウザが初期データを受信し、在室状況テーブルを描画する。

---

### 9. 環境変数一覧
`docker-compose.yml` および `README.md` で参照される主要な環境変数。`.env` ファイルにより定義される必要がある。

* **`mysql` サービス / `api` サービス共通:**
    * `MYSQL_DATABASE`: 使用するデータベース名 (例: OruCa_DB)。
    * `MYSQL_USER`: MySQLユーザー名。
    * `MYSQL_PASSWORD`: MySQLユーザーのパスワード。
* **`mysql` サービス専用:**
    * `MYSQL_ROOT_PASSWORD`: MySQLのrootパスワード。
* **`api` サービス専用:**
    * `SLACK_BOT_TOKEN`: Slack通知用のBotトークン。
    * `SLACK_CHANNEL_ID`: 通知を送信するSlackチャンネルID。
    * `TZ`: タイムゾーン (例: Asia/Tokyo)。
* **`nfc` サービス専用:**
    * `TZ`: タイムゾーン (例: Asia/Tokyo)。
