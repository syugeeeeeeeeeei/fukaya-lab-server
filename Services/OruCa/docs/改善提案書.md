## 📄 OruCaサービス 開発アーキテクチャ改善提案

### 結論
`OruCa`サービスの開発プロセスにおける諸課題を解決するため、**`pnpm`ワークスペース（モノレポ）** および **`Prisma`（ORM）** の導入を提案する。

これにより、開発時の型安全性を確立し、保守性を抜本的に改善する。なお、データベースは既存の**MySQLを継続利用**し、運用時のコンテナ分離構成 も維持する。本提案は、`init.sql` の廃止と、ストアドプロシージャ のAPI（TypeScript）コードへの移行を前提とする。

---

### 🏛️ 1. 課題①：型定義の二重管理

#### I. 問題の発生原因
現状、`api`サービス と`vite`サービス は、それぞれ独立した`package.json`を持つ個別のプロジェクトとして管理されている。このため、両者間でプログラム的に型情報を共有する手段がなく、APIのインターフェース定義（リクエストやレスポンスの型）などを、開発者が`api`側と`vite`側の双方で**手動で二重に定義・管理**せざるを得ない状況にある。

#### II. 解決の必要性
この「手動による型の二重管理」は、ヒューマンエラーの温床である。`api`側の仕様変更が`vite`側の型定義に即座に反映されないため、両者の型定義に**同期漏れ**が発生しやすい。この型の不一致は、コンパイル時（開発時）には検出できず、実行時（運用時）になって初めて露見する。これはアプリケーションの信頼性を著しく低下させ、バグの特定と修正コストを増大させる要因となる。

#### III. 解決策
**`pnpm`ワークスペース（モノレポ）** を導入する。
`OruCa`ディレクトリをモノレポのルートとし、その配下に`packages/api`、`packages/vite`、そして新たに**`packages/types`**（共有パッケージ）を配置する。

`api`と`vite`が共有すべき型定義（APIのレスポンス型など）を`packages/types`に集約し、`api`と`vite`の両方からこの共有パッケージを`import`する。

これにより、型定義の「信頼できる唯一の情報源（Single Source of Truth）」が確立される。`api`の仕様変更に伴い`packages/types`の型を修正すると、その型を利用する`vite`側で即座に**コンパイルエラー**が発生するようになる。これにより、実行時バグを未然に（開発段階で）検出し、修正することが可能となる。

---

### 2. 課題②：DBスキーマとコードの乖離

#### I. 問題の発生原因
現在、データベースのスキーマ（テーブル構造）は、`mysql/data/init.sql` というSQLファイルによって定義されている。一方で、`api`サービスは`mysql2` ドライバを用いてDBにアクセスしている。この`init.sql`（スキーマ定義）と`api`のTypeScriptコード（データアクセス）の間には、プログラム的な連携が一切存在しない。

#### II. 解決の必要性
`init.sql`（例：`logs`テーブル のカラム定義）を変更しても、その変更は`api`側のTypeScriptコードには自動的に伝達されない。開発者が`api`側のコード（例：SQLクエリやデータマッピング）を修正し忘れた場合、コンパイル時には何のエラーも発生しない。

この問題は、アプリケーションが実行され、該当するDBアクセスが行われた時点で、初めて「カラムが存在しない」等の**実行時データベースエラー**として表面化する。これは、スキーマとコードが容易に乖離しうる、極めて脆弱な状態と言える。

#### III. 解決策
**`Prisma`（ORM）** を導入し、`init.sql` でのスキーマ管理を**完全に廃止**する。

1.  `schema.prisma`ファイル（`provider = "mysql"`を指定）を`OruCa`プロジェクト内に新規作成し、ここに`init.sql` の内容（`users`, `logs`テーブル定義 など）をPrismaのモデルとして移行する。
2.  `prisma migrate dev`コマンドを用い、`schema.prisma`ファイルに基づいてMySQLデータベースのマイグレーション（スキーマ変更）を実行する。
3.  `prisma generate`コマンドを実行し、スキーマ定義に基づいた**型安全な`Prisma Client`** を自動生成する。

これにより、`schema.prisma`が「DBスキーマ」と「`api`のデータアクセス層」両方の単一の情報源となる。スキーマ（モデル）を変更すると、`Prisma Client`の型定義も自動で更新される。古いカラム名などにアクセスしようとすると、実行時ではなく**コンパイル時**にTypeScriptが型エラーとして検出し、修正を強制できる。

---

### 3. 課題③：ビジネスロジックの分散

#### I. 問題の発生原因
`insert_or_update_log` や `get_student_token` など、本来アプリケーション層の関心事であるべきビジネスロジックが、**ストアドプロシージャ**としてデータベース層（`init.sql`内）にSQLとして実装されている。

#### II. 解決の必要性
この構成は、複数の深刻な保守性・管理性の問題を引き起こす。
1.  **保守性の低下:** アプリケーションの振る舞いを理解するために、`api`のTypeScriptコード と`init.sql` の両方を読み解く必要があり、ロジックが分散し可読性が著しく低い。
2.  **テストの困難性:** TypeScriptの関数に比べて、ストアドプロシージャの単体テストは極めて困難である。
3.  **ORMとの非互換:** `Prisma`のようなORMは、ロジックがアプリケーション層にあることを前提としているため、ストアドプロシージャの存在はPrismaのマイグレーションや型生成の恩恵を阻害する。
4.  **技術的負債:** ロジックがSQLとTypeScriptの二言語にまたがることで、認知負荷と管理コストが増大する。

#### III. 解決策
ストアドプロシージャ を**完全に廃止**し、そこで行われていた処理をすべて **`api`サービスのTypeScriptコード内**に再実装する。

例えば、`insert_or_update_log` のロジックは、`api`サービス内の（例えば）`LogService`クラスなどに、`Prisma Client`の`upsert`（Update + Insert）メソッドを用いたTypeScriptの関数として移行する。

これにより、すべてのビジネスロジックが`api`（TypeScript）のコードベースに集約される。ロジックは型安全になり、単体テストも容易になる。データベースはデータ格納に専念し、「ロジックはアプリケーション層に」という責務の分離が明確化され、保守性が大幅に向上する。

---

### 4. 運用アーキテクチャの維持
本提案は、あくまで**開発体験（Developer Experience）** と**保守性**の向上を目的とするものである。

`docker-compose.yml` に定義されている通り、`api`, `web`, `mysql`, `nfc` が独立したコンテナとして稼働する**運用アーキテクチャ**は、疎結合でありスケーラビリティに優れるため、**現状のまま維持**する。

これにより、「開発時はモノレポの利便性」を享受しつつ、「運用時はマイクロサービス（コンテナ分離）の堅牢性」を両立させることが可能である。